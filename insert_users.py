import firebase_admin
from firebase_admin import credentials, firestore
from datetime import datetime

# Initialize Firebase Admin SDK
cred = credentials.Certificate("bundora.json")
firebase_admin.initialize_app(cred)

# Initialize Firestore
db = firestore.client()

# Enum mappings
MOOD_TYPE_MAPPING = {
    0: 'MOOD_UNSPECIFIED',
    1: 'MOOD_DEPRESSED',
    2: 'MOOD_FRUSTRATED',
    3: 'MOOD_SAD',
    4: 'MOOD_NEUTRAL',
    5: 'MOOD_GOOD',
    6: 'MOOD_HAPPY',
    7: 'MOOD_AWESOME'
}

AVATAR_TYPE_MAPPING = {
    0: 'AVATAR_TYPE_UNSPECIFIED',
    1: 'AVATAR_TYPE_1',
    2: 'AVATAR_TYPE_2',
    3: 'AVATAR_TYPE_3',
    4: 'AVATAR_TYPE_4',
    5: 'AVATAR_TYPE_5',
    6: 'AVATAR_TYPE_6'
}

CHARACTER_TYPE_MAPPING = {
    0: 'CHARACTER_TYPE_UNSPECIFIED',
    1: 'CHARACTER_TYPE_HELPING',
    2: 'CHARACTER_TYPE_HELPLESS'
}

# Function to convert Firestore timestamp to PostgreSQL TIMESTAMPTZ format
def convert_timestamp(firestore_timestamp):
    if firestore_timestamp:
        return datetime.utcfromtimestamp(firestore_timestamp.timestamp())
    return None

# Function to map Firestore data to initial SQL insert statements
def map_to_initial_sql(profile):
    firebase_id = profile['Id']

    # Handle CreatedAt: set to now if None
    created_at = convert_timestamp(profile.get('CreatedAt'))
    if created_at is None:
        created_at = datetime.utcnow()

    # Handle UpdatedAt and DeletedAt: keep as NULL if None
    updated_at = convert_timestamp(profile.get('UpdatedAt'))
    deleted_at = convert_timestamp(profile.get('DeletedAt'))

    onboarding_completed = profile.get('OnboardingCompleted', False)
    name = profile.get('Name')

    # Map integer values to corresponding enum types
    character_type = CHARACTER_TYPE_MAPPING.get(profile.get('CharacterType', 0))
    avatar_type = AVATAR_TYPE_MAPPING.get(profile.get('AvatarType', 0))
    current_mood = MOOD_TYPE_MAPPING[5 if profile.get('InGoodMood', False) else 4]  # Assuming InGoodMood corresponds to 'MOOD_GOOD'

    # Create SQL insert statement without specifying the id (UUID will be generated by PostgreSQL)
    sql = f"""
    INSERT INTO profiles (firebase_id, created_at, updated_at, deleted_at, onboarding_completed, name, character_type, avatar_type, current_mood)
    VALUES ('{firebase_id}', 
            '{created_at}'::timestamptz, 
            {'NULL' if updated_at is None else "'" + str(updated_at) + "'::timestamptz"}, 
            {'NULL' if deleted_at is None else "'" + str(deleted_at) + "'::timestamptz"}, 
            {onboarding_completed}, 
            {'NULL' if name is None else "'" + name + "'"}, 
            '{character_type}', 
            '{avatar_type}', 
            '{current_mood}'
    )
    RETURNING id;
    """
    return sql

# Function to map Firestore data to update partner_id relationship
def map_to_update_sql(profile, new_id, partner_firebase_id):
    if partner_firebase_id and partner_firebase_id in profile_uuid_map:
        partner_uuid = profile_uuid_map[partner_firebase_id]
        sql = f"""
        UPDATE profiles
        SET partner_id = '{partner_uuid}'
        WHERE id = '{new_id}';
        """
        return sql
    return None

# Retrieve data from Firestore
profile_uuid_map = {}

def retrieve_and_generate_sql():
    users_ref = db.collection('users')
    users = users_ref.stream()

    initial_sql_statements = []
    update_sql_statements = []

    for user in users:
        profile = user.to_dict()
        insert_sql = map_to_initial_sql(profile)
        initial_sql_statements.append(insert_sql)

    # Write initial insert statements to a SQL file
    with open('profiles_insert.sql', 'w') as f:
        f.write('\n'.join(initial_sql_statements))

    # Generate update statements for partner_id after inserts
    for user in users:
        profile = user.to_dict()
        partner_firebase_id = profile.get('Partner', {}).get('Id')
        if partner_firebase_id:
            update_sql = map_to_update_sql(profile, profile_uuid_map.get(profile['Id']), partner_firebase_id)
            if update_sql:
                update_sql_statements.append(update_sql)

    # Write update statements to a SQL file
    with open('insert_users.sql', 'w') as f:
        f.write('\n'.join(update_sql_statements))

if __name__ == "__main__":
    retrieve_and_generate_sql()
    print("SQL files generated successfully.")
